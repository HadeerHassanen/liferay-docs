<h1>3</h1>
<hr/><h1>Bridge Interface</h1><p>The <code>Bridge</code> interface is the main abstraction of the Portlet Bridge API. It defines the activation and invocation APIs whereby a portlet delegates processing to Faces. The bridge&rsquo;s lifecycle is similar to the portlet&rsquo;s lifecycle. Before executing requests, the bridge must be initialized and once the bridge becomes inactive it is destroyed. In a portlet application each portlet using the bridge&rsquo;s services maintains a distinct bridge instance. Typically, the portlet initializes the bridge in the portlet <code>init()</code> method and destroys it in the portlet <code>destroy()</code> method. However the only requirements are:</p>
<ul>
  <li>the portlet must initialize the bridge before having it process a portlet Faces request.</li>
  <li>that once initialized, the portlet must not reinitialize the bridge until after its current use has been destroyed.</li>
  <li>that once destroyed, a bridge must not be reused to process a portlet Faces request until it has been initialized again.</li>
</ul><a id="3"></a><h2>3.1 Discovering and Instantiating the Bridge</h2><p>The bridge is a pluggable component. The specific bridge implementation used by a portlet in a given deployment is controlled by the portlet. <code>Bridge</code> implementations are required to have null constructors. A portlet instantiates the designated bridge using the new operator. It is recommended that the portlet allow deployers the flexibility for designating the specific bridge this portlet uses in the given deployment environment. See <a href="Chapter-4-GenericFacesPortlet.html#4.1_Configuration">4.1</a> for a description on the techniques used by the <code>GenericFacesPortlet</code>.</p><p>A bridge must publish the specification name and version that it implements such that clients wishing to determine the specification version implemented by the bridge can get it from the package version information of any class in the API package (<code>javax.portlet.faces</code>):</p>
<pre><code>Class c = Class.forName(&quot;javax.portlet.faces.Bridge&quot;);
String name = c.getPackage().getSpecificationTitle();
String version = c.getPackage().getSpecificationVersion();
</code></pre><p>For this specification, the returned name must be &ldquo;Portlet 2.0 Bridge for JavaServer Faces 1.2&rdquo;<sup>[<a href="TCK-Tests.html#3.1">3.1</a>]</sup>. Its version number must correspond to the version of this specification that this bridge implements. The version number contains 2 places separated by a &ldquo;.&rdquo; (e.g. 1.0). The first number signifies the major version, the second number signifies the minor (maintenance) version.</p><a id="3"></a><h2>3.2 Initializing the Bridge</h2><p>A bridge is initialized by calling its init method:</p>
<pre><code>public void init(javax.portlet.PortletConfig config) throws BridgeException;
</code></pre><p>Once initialized, a bridge is bound to the portlet that initialized it until it has been released. I.e. an initialized bridge can&rsquo;t be shared between differing portlets in the same application<sup>[<a href="TCK-Tests.html#NT">nt</a>]</sup>.</p><p>The bridge initializes itself on the basis of application initialization parameters configured in the web.xml and <code>PortletContext</code> attributes set by the calling portlet. The bridge recognizes the following application initialization parameters:</p>
<pre><code>javax.portlet.faces.MAX_MANAGED_REQUEST_SCOPES
javax.portlet.faces.RENDER_POLICY
javax.faces.LIFECYCLE_ID
</code></pre><p><code>MAX_MANAGED_REQUEST_SCOPES</code> is an <code>Integer</code> valued configuration parameter that describes the maximum number of bridge request scopes maintained by the bridge at any given time for all the portlets in this web application<sup>[<a href="TCK-Tests.html#NT">nt</a>]</sup>. If not set the bridge provides an implementation dependent default maximum.</p><p><code>RENDER_POLICY</code> is a <code>javax.portlet.faces.Bridge.BridgeRenderPolicy</code> (enum) valued configuration parameter that when set controls whether or not the bridge delegates view rendering to another handler. Valid values include: <code>ALWAYS_DELEGATE</code>, <code>NEVER_DELEGATE</code>, <code>DEFAULT</code>. The value <code>ALWAYS_DELEGATE</code> indicates the bridge should not render the view itself but rather always delegate the rendering<sup>[<a href="TCK-Tests.html#3.2">3.2</a>]</sup>. The value <code>NEVER_DELEGATE</code> indicates the bridge should always render the view itself and never delegate<sup>[<a href="TCK-Tests.html#3.3">3.3</a>]</sup>. The value <code>DEFAULT</code> indicates the bridge should follow the requirements as specified <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#PLT_6.2">6.2</a> concerning implementing <code>renderView()</code>. This section directs the bridge to first delegate the render and if and only if an <code>Exception</code> is thrown then render the view based on its own logic<sup>[<a href="TCK-Tests.html#3.4">3.4</a>]</sup>. If the configuration parameter is not present or has an invalid value the bridge renders using default behavior<sup>[<a href="TCK-Tests.html#3.5">3.5</a>]</sup>. I.e. as if <code>DEFAULT</code> is set.</p>
<!-- Check to see if 6.2 link above works. -Cody --><p><code>LIFECYCLE_ID</code> is a String valued configuration parameter that describes the <code>ID</code> of the <code>Lifecycle</code> the bridge uses when executing Faces requests<sup>[<a href="TCK-Tests.html#3.6">3.6</a>]</sup>. If not set the bridge uses the ID for the default lifecycle (<code>LifecycleFactory.DEFAULT_LIFECYCLE</code>)<sup>[<a href="TCK-Tests.html#3.7">3.7</a>]</sup>.</p><p>In addition the portlet can impact a bridge&rsquo;s initialization by setting specific <code>PortletContext</code> attributes prior to calling <code>init()</code>. Because <code>PortletContext</code> attributes are application wide, to carry initialization parameters on a per portlet basis, the attribute name is encoded with the portlet name as described below.</p><p>The defined attributes are:</p>
<pre><code>javax.portlet.faces.[portlet name].excludedRequestAttributes
javax.portlet.faces.[portlet name].preserveActionParams
javax.portlet.faces.[portlet name].defaultViewIdMap
javax.portlet.faces.[portlet name].bridgeEventHandler
javax.portlet.faces.[portlet name].bridgePublicRenderParameterHandler
javax.portlet.faces.[portlet name].defaultRenderKitId
</code></pre><p>where <code>[portlet name]</code> is the name of the portlet returned from a <code>PortletConfig.getPortletName()</code>.</p><p><code>excludedRequestAttributes</code> is an attribute whose value is a <code>List</code> of <code>String</code> objects each of which either defines a specific attribute name the bridge is to exclude from its managed request scope or defines a set of attributes the bridge is to exclude from its managed request scope<sup>[<a href="TCK-Tests.html#3.8">3.8</a>]</sup>. The later is identified by a <code>String</code> value with the wildcarded suffix &ldquo;.*&rdquo;. Such wildcard usage indicates the bridge is to exclude all those attributes within the namespace identified by removing the &ldquo;*&rdquo;<sup>[<a href="TCK-Tests.html#3.9">3.9</a>]</sup>.</p><p><code>preserveActionParams</code> is a <code>Boolean</code> valued attribute that when <code>TRUE</code> indicates the bridge must maintain the action&rsquo;s request parameters for the duration of the bridge request scope<sup>[<a href="TCK-Tests.html#3.10">3.10</a>]</sup> <a href="Chapter-5-Bridge-Lifecycle-Requirements.html#PLT_5.1.2">5.1.2</a>. When this attribute isn&rsquo;t present or is <code>FALSE</code> the action&rsquo;s request parameters are only maintained for the duration of the portlet request scope. The exception to this is the <code>ResponseStateManager.VIEW_STATE_PARAM</code> parameter which is always maintained in the bridge request scope regardless of this setting<sup>[<a href="TCK-Tests.html#3.11">3.11</a>]</sup>.</p><p><code>defaultViewIdMap</code> is a <code>Map&lt;String, String&gt;</code> valued attribute containing one entry per supported <code>PortletMode</code>. The <code>Map</code> key is the <code>String</code> name of the <code>PortletMode</code>. The <code>Map</code> value is the default Faces <code>viewId</code> for the mode<sup>[<a href="TCK-Tests.html#3.12">3.12</a>]</sup>.</p><p><code>bridgeEventHandler</code> is a (instanceof) <code>BridgeEventHandler</code> valued attribute identifying the instance that is called to handle portlet events received by the bridge<sup>[<a href="TCK-Tests.html#3.20">3.20</a>]</sup>.</p><p><code>bridgePublicRenderParameterHandler</code> is a (instanceof) <code>BridgePublicRenderParameterHandler</code> valued attribute identifying the instance that is called to postprocess incoming public render parameter changes after the bridge has pushed these values into the mapped managed beans. This handler gives the portlet an opportunity to recompute and get into a new consistent state after such changes<sup>[<a href="TCK-Tests.html#3.20">3.20</a>]</sup>.</p><p><code>defaultRenderKitId</code> is a String valued attribute identifying the renderkit id the bridge should encode as a request parameter in each request to ensure that Faces will use this Id when resolving the renderkit used by this portlet<sup>[<a href="TCK-Tests.html#3.22">3.22</a>]</sup>. If this attribute doesn&rsquo;t exist, the bridge takes no action, leaving the renderkit resolution to normal Faces resolution.</p><p>Non-standard attributes should follow a similar naming convention: </p><p><strong>application wide attributes</strong>: attributes should be named <code>javax.portlet.faces.extension.</code><em>[extension_pkg].[attribute name]</em>. Where <em>extension_pkg</em> is further namespacing introduced by the extension authors to avoid collisions with other (types of) extensions.</p><p><strong>portlet specific attributes</strong>: attributes should be named <code>javax.portlet.faces.extension.</code><em>[extension_pkg].[portlet name].[attribute name]</em> where <em>portlet name</em> is the name of the portlet returned from a <code>PortletConfig.getPortletName()</code> call and <em>attribute name</em> is the name of the attribute. Using <em>portlet name</em> ensures the bridge can locate the correct value on a per portlet basis.</p><a id="3"></a><h2>3.3 Destroying the Bridge</h2><p>The bridge is destroyed by calling its destroy method:</p><p>public void destroy();</p><p>When a portlet no longer needs the bridge&rsquo;s services, the portlet releases the bridge by calling the destroy() method. Typically this is done in the portlet&rsquo;s own destroy() method. Once destroy() has been called, no further requests can be processed through this bridge until a subsequent init() has occurred[3.13].</p><p>This call performs no action if the bridge is in an uninitialized state[3.14]. 3.4 Request Processing The bridge is used to execute Faces requests on behalf of the portlet by calling its doFacesRequest method:</p><p>public void doFacesRequest(  javax.portlet.ActionRequest request,  javax.portlet.ActionResponse response)  throws BridgeUnititializedException, BridgeDefaultViewNotSpecifiedException,  BridgeException, NullPointerException;</p><p>public void doFacesRequest(  javax.portlet.RenderRequest request,  javax.portlet.RenderResponse response);  throws BridgeUnititializedException, BridgeDefaultViewNotSpecifiedException,  BridgeException, NullPointerException;</p><p>public void doFacesRequest(ResourceRequest request, ResourceResponse response)  throws BridgeUninitializedException,  BridgeException;</p><p>public void doFacesRequest(EventRequest request, EventResponse response)  throws BridgeUninitializedException,  BridgeException;</p><p>Portlets call the appropriate form of this method for each of the request phases in the portlet lifecycle. In Portlet 2.0 the lifecycle can be more complicated than in Portlet 1.0. I.e. a typical Java Portlet Specification 1.0 (JSR 168) portlet lifecycle invokes the portlet processAction() and render() methods which results in two calls to the bridge&rsquo;s doFacesRequest(). The first processes the action request by passing the corresponding ActionRequest and ActionResponse objects and the second the render request by passing the corresponding RenderRequest and RenderResponse objects. Likewise, when a Java Portlet Specification 1.0 (JSR 168) portlet lifecycle only invokes render() such as on the initial request or as a result of renderURL invocation, doFacesRequest() is only executed once passing the corresponding RenderRequest and RenderResponse objects.</p><p>Though this lifecycle remains for Portlet 2.0, additional phases can occur/replace the Portlet 1.0 phases. Portlet events are communications sent to a portlet by the consuming application to convey pertinent information when interactions occur outside of this portlet. i.e. if a portlet action is the lifecycle phase executed when a user directly interacts with the portlet, a portlet event is the lifecycle phase when an interaction outside of this portlet causes the consumer to need to inform this portlet of the change. Because the portlet model calls for all events (stemming from a client interaction) to be completed before rendering occurs and event processing can trigger new events to be raised, a portlet can either receive the event as a side effect of it having raised an event during its own action processing or in the more common form of the action being directed elsewhere.</p><p>The other new request lifecycle phase in Portlet 2.0 is the resource serving phase. Whereas in Portlet 1.0 resources couldn&rsquo;t be directly served by the portlet but rather had to be referenced via direct http references, Portlet 2.0 allows a portlet to directly return dependent resources. One common use case for this new lifecycle is to implement &ldquo;rich client&rdquo; behaviors using technologies such as AJAX. In this use case the resource is a portion of the portlet&rsquo;s page markup which the client requests and inserts directly. Whether this or the more convention use case of acquiring a dependent resource such as a javascript file or image, the resource phase can be thought of as an additional step that is part of but after a render phase. </p><p>Each of the doFacesRequest lifecycle phase methods takes a portlet request and response object. In addition to the incoming information in the portlet request, the portlet provides additional bridge request context by setting attributes in the request using PortletRequest.setAttribute(). To direct the bridge to execute a specific Faces target the portlet can set either of the following before calling doFacesRequest:</p><p>javax.portlet.faces.viewId: The value of this attribute identifies the Faces viewId the bridge must use for this request (e.g. /myFacesPage.jsp). This is expected to be a valid Faces viewId though it may optionally contain a query string[3.15].</p><p>javax.portlet.faces.viewPath: The value of this attribute contains the the Faces viewId the bridge must use for this request in ContextPath relative path form (e.g. /faces/myFacesPage.jsp). This value may optionally contain a query string[3.16].</p><p>The BridgeUninitializedException is thrown if this method is called while the bridge is in an uninitialized state[3.17]. The NullPointerException is thrown if either the passed request or response objects are null[3.18]. </p>
