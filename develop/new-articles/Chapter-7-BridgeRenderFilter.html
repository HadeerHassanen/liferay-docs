<h1>7</h1>
<hr/><h1>Supporting Faces WriteBehindResponse</h1><p>In JavaServer&trade; Faces 1.2, a JSP is the primary page format for representing a Faces view. Faces provides a set of taglibs which developers reference to describe their view. When a JSP is rendered, the Faces tag implementations are invoked which constructs the view tree. After JSP processing is complete, control returns to Faces which then renders the Faces markup by rendering the view tree. Because JSP rendering and Faces (view) rendering occur at different stages of the rendering phase, any output rendered within the JSP itself (literal strings/static html or jsp/java rendered markup) will be output before the Faces view markup regardless of whether it logically appears before of after the Faces view description in the JSP. To preserve the natural order in a JSP, Faces 1.2 utilizes an implementation dependent write behind mechanism which generally uses the following pattern:</p>
<ul>
  <li>Defines a response wrapper class/interface that includes implementation dependent APIs.</li>
  <li>Implements its Faces <code>view</code> tag handler (and maybe others) to check if the current response object (on the <code>ExternalContext</code>) supports the implementation dependent API, and if so call the method to flush any existing (prior JSP) output to the real response stream before processing the tag and building the Faces <code>view</code>.</li>
  <li>Implements its <code>ViewHandler</code>, to replace the existing <code>ExternalContext</code> response object with with one that implements the extended implementation dependent API before dispatching to the JSP. And then once the dispatch has returned, it restores the prior response object to the <code>ExternalContext</code>, renders the Faces <code>view</code> and then calls another of the implementation dependent APIs on the response object it dispatched with to output any remaining (buffered) markup.</li>
</ul><p>Because the JSF specification prescribes this behavior without formalizing the mechanism, the bridge must. The bridge defines two formal mechanisms. One, relies on a <code>ServletFilter</code> and was defined for the Portlet 1.0 Bridge because <code>PortletResponseWrappers</code> weren&rsquo;t part of the portlet 1.0 specification. Its support continues for backwards compatibility and for those Faces implementations where the implementation of the bridge&rsquo;s second mechanism isn&rsquo;t feasible. The second, mirrors the pattern described above using a <code>PortletResponseWrapper</code> that implements a required bridge write behind interface which supports and works in conjunction with the Faces implementation dependent API needed by the (<code>view</code>) tag handlers.</p><p>The bridge is required to support both of these mechanisms simultaneously in its provided ViewHandler [<a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.2.1">6.2.1</a>].</p><a id="a-name71"></a><h2><a name="7.1"></a>7.1 Support via a ServletFilter</h2><p>The bridge&rsquo;s <code>ServletFilter</code> mechanism is for use when either the Faces implementation&rsquo;s mechanism can&rsquo;t be incorporated into the bridge&rsquo;s wrapper mechanism or to continue (backwards compatibility) support from the Portlet 1.0 Bridge when portlet wrappers didn&rsquo;t exist. The bridge&rsquo;s responsibility is as follows:</p>
<ul>
  <li>Prior to dispatching to the JSP, the bridge&rsquo;s <code>ViewHandler</code> sets the <code>javax.portlet.faces.RenderContentAfterView</code> attribute with a boolean value of <code>Boolean.TRUE</code>.</li>
  <li>After the dispatch completes and the <code>ViewHandler</code> has rendered the Faces view, the <code>ViewHandler</code> gets and outputs any write behind markup be reading the request attribute <code>javax.portlet.faces.AfterViewContent</code> (containing either a <code>byte[]</code> or <code>char[]</code>)</li>
</ul><p>To enable and use this mechanism, the portlet developer implements and configures a <code>ServletFilter</code> that has the following behavior:</p>
<ul>
  <li>When invoked, if the <code>javax.portlet.faces.RenderContentAfterView</code> attribute exists and has a value of <code>Boolean.TRUE</code>, wrap the incoming <code>ServletResponse</code> with either the implementation dependent <code>ServletResponseWrapper</code> used by the particular Faces implementation being used or one that supports its required API and behavior. Replace the <code>ExternalContext response</code> object with this wrapper caching the current one and then call the filter chain to execute the render.</li>
  <li>Upon completion, restore the <code>ExternalContext response</code> object, get the after view content from the wrapped response using its proprietary API, and write this content (as a <code>byte[]</code> or <code>char[]</code>) as the value of the request attribute <code>javax.portlet.faces.AfterViewContent</code>.</li>
</ul><a id="a-name711"></a><h3><a name="7.1.1"></a>7.1.1 Example Configuration</h3><p>As a <code>ServletFilter</code>, the write behind filter is configured in the application&rsquo;s <code>web.xml</code>. It should only be configured to filter included requests:</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;myFacesRenderBehindPortletFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.myfaces.portlet.faces.application.BridgeMyFacesRenderFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;myFacesRenderBehindPortletFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;myFacesRenderBehindPortletFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre><a id="a-name712"></a><h3><a name="7.1.2"></a>7.1.2 Version Considerations</h3><p>The following Faces implementation versions implement its dependent write behind behavior exclusively in a <code>ServletResponseWrapper</code> without independently defining a non-Servlet dependent interface:</p>
<ul>
  <li>Mojarra 1.2_03</li>
  <li>All released version of MyFaces 1.2 (current version is 1.2.9)</li>
</ul><p>I.e. the Faces view tag handler(s) test to see if the response supports its write behind behavior involves checking whether the response object is an instance of the particular <code>ServletResponseWrapper</code> it has implemented.</p><p>Because, the bridge&rsquo;s write behind wrapper mechanism requires the behavior be implemented in an object that both extends <code>PortletResponseWrapper</code> and implements the <code>BridgeWriteBehindResponse</code> interface, this mechanism is incompatible with the above versions. If the target runtime environment will contain any of these versions, one must use this servlet filter mechanism to support the write behind behavior.</p><a id="a-name713"></a><h3><a name="7.1.3"></a>7.1.3 Performance Considerations</h3><p>Through the use of the request attribute to signal the filter to introduce its support, the mechanism is designed to have negligible impact when invoked from non-portlet requests. However, some overhead exists because the Servlet container has to determine whether this filter should be called (i.e. if its an include) and if invoked whether the filter needs to act (based on existence/setting of the <code>javax.portlet.faces.RenderContentAfterView</code> attribute. In addition, because this facility isn&rsquo;t provided by default; setting up the filter requires extra configuration. Because many JSF/JSP pages aren&rsquo;t coded in a manner that exhibits this ordering problem, portlet developers should keep the above in mind when deciding whether enabling the filter in their application is justified.</p><a id="a-name72"></a><h2><a name="7.2"></a>7.2 Support via Portlet 2.0 ResponseWrapper</h2><p>The bridge&rsquo;s <code>PortletResponseWrapper</code> mechanism follows a pattern similar to Faces <code>ServletResponseWrapper</code> mechanism. The bridge has the following responsibility:</p>
<ul>
  <li>In the bridge&rsquo;s <code>ViewHandler</code>, prior to dispatching to the JSP, replace the existing <code>ExternalContext response</code> with one that subclasses the appropriate phase&rsquo;s <code>PortletResponseWrapper</code> class and implements the bridge&rsquo;s <code>javax.portlet.faces.BridgeWriteBehindResponse</code> interface.</li>
  <li>Dispatch to the JSP.</li>
  <li>Restore the prior <code>ExternalContext</code> response</li>
  <li>Call the wrapper&rsquo;s <code>hasWriteBehindMarkup()</code> method and if it returns <code>true</code> and something hasn&rsquo;t already set the <code>javax.portlet.faces.AfterViewContent</code> request attribute then hold onto the wrappers content for later output. Otherwise, write its buffered content to the response.</li>
  <li>Render the Faces view.</li>
  <li>Output the (cached) after view content.</li>
</ul><p>For this mechanism to work, the <code>PortletResponseWrapper</code> must additionally support the particular Faces dependent API used by the (view) tag handler to flush the prior view content. The particular wrapper used by the bridge is configured by the portlet in <code>faces-config.xml</code>. In the absence of such configuration, the bridge may use its own response wrapper that is designed to work automatically in the Faces environments it targets. For example, where Faces write behind implementations exist that have their tag handlers rely on Java reflection to determine support, the implementation of the default response wrapper should support any such additional APIs as needed by these implementations to allow these classes to be used directly in the above mechanism and achieve write behind behavior.</p><a id="a-name721"></a><h3><a name="7.2.1"></a>7.2.1 Configuring the Bridge to use a PortletResponseWrapper/WriteBehindResponse implementation</h3><p>One configures the particular implementation of the <code>RenderResponseWrapper</code> and/or <code>ResourceResponseWrapper</code> the bridge uses as the response object it dispatches to in the bridge&rsquo;s <code>application-extension</code> section of the <code>face-config.xml</code><sup>[<a href="TCK-Tests.html#7.1">7.1</a>]</sup>. The syntax for this is described in <code>portlet2.0-bridge-faces1.2-faces-config-extensions.xsd</code>.</p>
<pre><code>&lt;application&gt;
    &lt;application-extension&gt;
        &lt;bridge:write-behind-response-wrappers&gt;
            &lt;bridge:render-response-wrapper-class&gt;
                org.mypackage.MyWriteBehindRenderResponseWrapper
            &lt;/bridge:render-response-wrapper-class&gt;

            &lt;bridge:resource-response-wrapper-class&gt;
                org.mypackage.MyWriteBehindResourceResponseWrapper
            &lt;/bridge:resource-response-wrapper-class&gt;
        &lt;/bridge:write-behind-response-wrappers&gt;      
    &lt;/application-extension&gt;
&lt;/application&gt;
</code></pre><a id="a-name722"></a><h3><a name="7.2.2"></a>7.2.2 Version Considerations</h3><p>Mojarra version 1.2_03 tag handlers detect write behind support by using <code>instanceof</code> a particular <code>ServletResponseWrapper</code> class. This class is incompatible with this <code>PortletResponseWrapper</code> mechanism, hence only the <code>ServletFilter</code> mechanism can be used to add write behind support.</p><p>Mojarra version 1.2_04 through 1.2_07 tag handlers detect write behind support by using <code>instanceof</code> a particular interface (<code>InterleavingResponse</code>) the response object might additionally implement. In such an environment, developers need to implement and configure appropriate <code>PortletResponseWrapper</code> classes that additionally implement both the <code>BridgeWriteBehindResponse</code> interface and the <code>InterleavingResponse</code> interface.</p><p>Mojarra version 1.2.08 through current (1.2_13) tag handlers detect write behind behavior by using Java reflection to detect if the response class implements the needed method. The supported methods correspond to those methods defined in the <code>InterleavingResponse</code> interface. The bridge should implement and use default <code>PortletResponseWrapper</code> classes that not only implements the <code>BridgeWriteBehindResponse</code> interface but also supports the methods defined in the <code>InterleavingResponse</code> interface. In such circumstances, because reflection is being used, the bridge can continue to be Faces implementation independent yet still automatically support write behind behavior when run in one of these versions. If a particular bridge doesn&rsquo;t naturally support these methods, a developer can enable write behind support by configuring the application with the same write behind <code>PorttletResponseWrapper</code>(s) that work for versions 1.2_04-1.2_07.</p><p>All (existing) MyFaces versions (1.2.2-1.2.9) tag handlers detect write behind support by using <code>instanceof</code> a particular <code>ServletResponseWrapper</code> class. This class is incompatible with this <code>PortletResponseWrapper</code> mechanism, hence only the <code>ServletFilter</code> mechanism can be used to add write behind support.</p><p><span style="font-weight: bold;"></span></span></div> <table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td>&nbsp; <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html">Previous</a></td> <td style="text-align: center;"><a href="TOC.html">Portlet 2.0 Bridge for JavaServer<small><sup>TM</sup></small>Faces 1.2 &ndash; November 14th, 2010</a></td> <td style="text-align: right;"><a href="Chapter-8-Faces-Extensions-in-the-Bridge-Environment.html">Next</a> &nbsp;</td> </tr> </tbody> </table></p>
