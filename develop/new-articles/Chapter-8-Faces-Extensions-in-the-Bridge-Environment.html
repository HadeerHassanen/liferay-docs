<h1>8</h1>
<hr/><h1>Faces Extensions in the Bridge Environment</h1><p>It is common for Faces applications to run in an extended Faces environment. I.e. one where the applications relies on function not provided in the base (reference) implementation but rather is provided by an implementation using one of the many extensions mechanisms Faces defines. As the portlet bridge also is in part built as a Faces extension consideration needs to be given by these other Faces extension developers to ensure proper execution in a portlet environment..</p><a id="a-name81"></a><h2><a name="8.1"></a>8.1 Configuration</h2><p>Because its the bridge&rsquo;s implementation that abstracts the details of running in a portlet environment its important that the bridge extensions execute as close as possible to the base layer as possible. This is why the bridge&rsquo;s <code>FacesContextFactory</code> is configured as a service provider. To run correctly all other application extensions that aren&rsquo;t defined in the application&rsquo;s <code>faces-config.xml</code> should be configured in the <code>META-INF/faces-config.xml</code> in their jar file. They should not be registered as a service provider.</p><p>Unfortunately, the Faces extensions implemented by the bridge aren&rsquo;t limited to those that are configured via the service provider mechanism. The bridge also extends the <code>ViewHandler</code> and <code>StateManager</code>[<a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.2">6.2</a> and <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.3">6.3</a>]. The <code>ViewHandler</code> and <code>StateManager</code> are configured in its <code>faces-config.xml</code> that its in the <code>META-INF</code> directory of its <code>jar</code> file. As Faces doesn&rsquo;t define a set precedence order when like configuration exists in other <code>faces-config.xml</code> files that are also in a <code>jar</code>&rsquo;s <code>META-INF</code> directory, one can&rsquo;t control or determine whether or where in the <code>ViewHandler</code> or <code>StateManager</code> chains the bridge&rsquo;s implementation will be called. To avoid obscuring other extensions, the bridge delegates where ever possible and then augments the result. When this is not feasible, the bridge ensures it at least duplicates the behavior defined by the RI for this function. Other extensions are expected to be implemented in a similar manner to avoid obscuring necessary bridge behavior. I.e. they either delegate to ensure the bridge gets a chance to execute or they implement the bridge&rsquo;s function directly. Sections <a href="Chapter-8-Faces-Extensions-in-the-Bridge-Environment.html#8.5">8.5</a> and <a href="Chapter-8-Faces-Extensions-in-the-Bridge-Environment.html#8.6">8.6</a> discusses this in detail.</p><a id="a-name82"></a><h2><a name="8.2"></a>8.2 Initializing Extensions</h2><p>If an extension subsystem needs to perform one time initialization, it is recommended it rely on providing a ServletContext listener as defined in the Servlet specification.</p><p>If an extension subsystem needs to perform per request initialization, it is recommended it provide its own implementation of FacesContextFactory and perform this initialization in the appropriate activation calling sequence.</p><p>Commonly such initialization involves wrapping either the request or response objects to support extended semantics on these objects. In the Servlet environment extensions have two options, they can wrap the request or response object before delegating the creation of the FacesContext/ExternalContext or they can wrap later and replace the request/response object managed by the ExternalContext using the setRequest or setResponse calls. Because the portlet API doesn&rsquo;t directly support such wrapping, extensions must only use the later mechanism when wrapping a portlet request or response. I.e. so that the bridge can properly dispatch Faces requests it must be constructed with the original portlet request and response objects.</p><p>Some Faces extensions use servlet filters to manage they per request initializations/processing. Because filters aren&rsquo;t supported in the portlet environment, this will not work. Instead its recommended the extension use the &ldquo;provide a FacesContextFactory&rdquo; technique discussed in this section.<br/>8.3 Portlet Considerations There may be times when an extension needs to determine if its running in a portlet vs. a servlet environment. Generally the check needs to be made without regard to whether the bridge and/or portlet container are actually deployed in the environment. The simplest technique relying on instanceof javax.servlet.ServletRequest(Response) is insufficient because some portlet containers may have extended the underlying servlet request/response object in implementing PortletRequest/PortletResponse. Instead the extension should look for the existence of the bridge&rsquo;s request attribute which holds the current portlet phase. The attribute name is javax.portlet.faces.phase. If this attribute exists it is a portlet request.</p><p>boolean isPortletRequest =  externalContext.getRequestMap().containsKey(&ldquo;javax.portlet.faces.phase&rdquo;);</p><p>When the bridge can be assumed to be deployed in the application, the utility method javax.portlet.faces.BridgeUtil.isPortletRequest() may be used instead.</p><p>Additionally, if the Faces extension utilizes a Lifecycle listener, it likely needs to be modified to run properly in a portlet environment. A portlet application can contain many portlets each relying on their own instance of the bridge. The Faces Lifecycle however is application scoped, hence any Lifecycle listeners are also application scoped. This means a Lifecycle listener registered on a Lifecycle in one portlet will actually be registered and called for all portlets receiving requests for the duration of the registration. To avoid doing inappropriate or duplicate work, the Lifecycle listener code should include a check to only operate if its operating within the current FacesContext. I.e. Surround the listener function with a condition check that ensures the FacesContext passed in the event parameter to the method is the same as the FacesContext in the current thread (FacesContext.getCurrentInstance). 8.4 General Considerations Extensions should:</p>
<pre><code>avoid interacting directly with container specific objects.  Instead rely on the ExternalContext abstraction.
when interacting directly with container specific objects, provide support for both the Servlet and Portlet containers.
avoid completely overriding any method.  Where its necessary to do so, the extension must provide equivalent function as specified in this specification. 
avoid caching the FacesContext and other dependent objects in your own variables.  In the portlet model the action and render phases span requests. A likely bridge implementation creates/destroys the FacesContext for each request.  This means a different FacesContext (and dependent) instance exists during the action phase then in the render phase.  If you cache such instances you will be referencing the wrong, destroyed instance.
</code></pre><p>8.5 Cohabiting with the Bridge&rsquo;s ViewHandler Because of limitations in the Faces configuration environment there is no way to order extensions that are defined (exclusively) in the faces-config.xml. This applies to the Faces ViewHandler. This means when running in an environment where other subsystems also introduce a ViewHandler, one can&rsquo;t predict whether the bridge&rsquo;s ViewHandler will take precedence or not. The bridge is designed to cohabit with these other ViewHandlers regardless of the actual precedence order. However the same may not be true of these other ViewHandlers. To work correctly in a portlet environment with the bridge, other ViewHandler extensions are expected to:</p>
<pre><code>Not run any (servlet) non-portlet container specific code when executing a portlet request.
If the extension&#39;s ViewHandler.createView() returns its own UIViewRoot whose Class.getName isn&#39;t javax.faces.component.UIViewRoot then the extension should have its UIViewRoot implement the same semantics for portlet namespacing as described in section 6.6.  I.e. the implementation class of its UIViewRoot should be annotated to indicate it implements the portlet namespacing semantics and also provide such an implementation.
If the extension&#39;s ViewHandler.renderView() handles its own form of rendering then the extension should ensure the same style of response interleaving as provided by the default renderView and the bridge.
</code></pre><p>8.6 Cohabiting with the Bridge&rsquo;s StateManager Because of limitations in the Faces configuration environment there is no way to order extensions that are defined (exclusively) in the faces-config.xml. This applies to the Faces StateManager. This means when running in an environment where other subsystems also introduce a StateManager one can&rsquo;t predict whether the bridge&rsquo;s StateManager will take precedence or not. The bridge is designed to cohabit with these other StateManagers regardless of the actual precedence order. However the same may not be true of these other StateManagers. To work correctly in a portlet environment with the bridge, other StateManager extensions are expected to:</p>
<pre><code>Not generate any output directly within the writeState(FacesContext context, Object state). I.e. the extension should rely/override other methods that are called when writeState is executed to generate any output.  If this is not feasible, the extension developer should document the issue to inform portlet application developers that when using the extension in a bridge environment they need to move the StateManager configuration from the bridge jar&#39;s faces-config.xml and put it into the applications (WEB-INF) faces-config.xml.  This ensures the bridge&#39;s StateManager runs before the extensions and hence isn&#39;t obscured by it.
Delegate writeState(FacesContext context, Object state) to the next StateManager in the chain.  Note:  a common practice when implementing a StateManager (in earlier Faces versions) was to extend javax.faces.application.StateManager and to delegate calls to this super class.  To work properly with the bridge such implementations need to change to delegate to the next StateManager in the chain.  This is most easily done by reimplementing the StateManager as an extension of javax.faces.application.StateManagerWrapper.
</code></pre><p>8.7 Excluding Attributes When executing an extension may store temporary state in the request scope. Because the bridge extends the life of this scope, extensions should explicitly exclude those attributes which do not need to be preserved. I.e. are recreated as needed in each (portlet) request. The preferred way to exclude such an attribute is to annotate the class of the attribute&rsquo;s value with javax.portlet.faces.annotation.ExcludeFromManagedRequestScope. If this is not feasible, attributes can be excluded by declaring them in the extension jar&rsquo;s faces-config.xml as described in 5.1.2.1. When using this technique care should be taken to only exclude attributes that are uniquely namespaced as other portlets in the same web application may rely on other extensions and/or attributes that might collide with a non-unique name and be mistakenly excluded. In such a situation when non-uniquely namespaced attributes are used, the extension developer should merely document for the portlet developer her need to configure such an exclusion in the application&rsquo;s portlet.xml for each portlet that utilizes the extension.</p>
