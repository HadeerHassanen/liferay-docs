<h1>8</h1>
<hr/><h1>Faces Extensions in the Bridge Environment</h1><p>It is common for Faces applications to run in an extended Faces environment. I.e. one where the applications relies on function not provided in the base (reference) implementation but rather is provided by an implementation using one of the many extensions mechanisms Faces defines. As the portlet bridge also is in part built as a Faces extension consideration needs to be given by these other Faces extension developers to ensure proper execution in a portlet environment..</p><a id="a-name81"></a><h2><a name="8.1"></a>8.1 Configuration</h2><p>Because its the bridge&rsquo;s implementation that abstracts the details of running in a portlet environment its important that the bridge extensions execute as close as possible to the base layer as possible. This is why the bridge&rsquo;s <code>FacesContextFactory</code> is configured as a service provider. To run correctly all other application extensions that aren&rsquo;t defined in the application&rsquo;s <code>faces-config.xml</code> should be configured in the <code>META-INF/faces-config.xml</code> in their jar file. They should not be registered as a service provider.</p><p>Unfortunately, the Faces extensions implemented by the bridge aren&rsquo;t limited to those that are configured via the service provider mechanism. The bridge also extends the <code>ViewHandler</code> and <code>StateManager</code>[<a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.2">6.2</a> and <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.3">6.3</a>]. The <code>ViewHandler</code> and <code>StateManager</code> are configured in its <code>faces-config.xml</code> that its in the <code>META-INF</code> directory of its <code>jar</code> file. As Faces doesn&rsquo;t define a set precedence order when like configuration exists in other <code>faces-config.xml</code> files that are also in a <code>jar</code>&rsquo;s <code>META-INF</code> directory, one can&rsquo;t control or determine whether or where in the <code>ViewHandler</code> or <code>StateManager</code> chains the bridge&rsquo;s implementation will be called. To avoid obscuring other extensions, the bridge delegates where ever possible and then augments the result. When this is not feasible, the bridge ensures it at least duplicates the behavior defined by the RI for this function. Other extensions are expected to be implemented in a similar manner to avoid obscuring necessary bridge behavior. I.e. they either delegate to ensure the bridge gets a chance to execute or they implement the bridge&rsquo;s function directly. Sections <a href="Chapter-8-Faces-Extensions-in-the-Bridge-Environment.html#8.5">8.5</a> and <a href="Chapter-8-Faces-Extensions-in-the-Bridge-Environment.html#8.6">8.6</a> discusses this in detail.</p><a id="a-name82"></a><h2><a name="8.2"></a>8.2 Initializing Extensions</h2><p>If an extension subsystem needs to perform one time initialization, it is recommended it rely on providing a <code>ServletContext</code> listener as defined in the Servlet specification.</p><p>If an extension subsystem needs to perform per request initialization, it is recommended it provide its own implementation of <code>FacesContextFactory</code> and perform this initialization in the appropriate activation calling sequence.</p><p>Commonly such initialization involves wrapping either the request or response objects to support extended semantics on these objects. In the Servlet environment extensions have two options, they can wrap the request or response object before delegating the creation of the <code>FacesContext</code>/<code>ExternalContext</code> or they can wrap later and replace the request/response object managed by the <code>ExternalContext</code> using the <code>setRequest</code> or <code>setResponse</code> calls. Because the portlet API doesn&rsquo;t directly support such wrapping, extensions must only use the later mechanism when wrapping a portlet request or response. I.e. so that the bridge can properly dispatch Faces requests it must be constructed with the original portlet request and response objects.</p><p>Some Faces extensions use servlet filters to manage they per request initializations/processing. Because filters aren&rsquo;t supported in the portlet environment, this will not work. Instead its recommended the extension use the &ldquo;provide a <code>FacesContextFactory</code>&rdquo; technique discussed in this section.</p><a id="a-name83"></a><h2><a name="8.3"></a>8.3 Portlet Considerations</h2><p>There may be times when an extension needs to determine if its running in a portlet vs. a servlet environment. Generally the check needs to be made without regard to whether the bridge and/or portlet container are actually deployed in the environment. The simplest technique relying on <code>instanceof
javax.servlet.ServletRequest(Response)</code> is insufficient because some portlet containers may have extended the underlying servlet request/response object in implementing <code>PortletRequest</code>/<code>PortletResponse</code>. Instead the extension should look for the existence of the bridge&rsquo;s request attribute which holds the current portlet phase. The attribute name is <code>javax.portlet.faces.phase</code>. If this attribute exists it is a portlet request.</p>
<pre><code>boolean isPortletRequest = externalContext.getRequestMap().containsKey(&quot;javax.portlet.faces.phase&quot;);
</code></pre><p>When the bridge can be assumed to be deployed in the application, the utility method <code>javax.portlet.faces.BridgeUtil.isPortletRequest()</code> may be used instead.</p><p>Additionally, if the Faces extension utilizes a <code>Lifecycle</code> listener, it likely needs to be modified to run properly in a portlet environment. A portlet application can contain many portlets each relying on their own instance of the bridge. The Faces <code>Lifecycle</code> however is application scoped, hence any <code>Lifecycle</code> listeners are also application scoped. This means a <code>Lifecycle</code> listener registered on a Lifecycle in one portlet will actually be registered and called for all portlets receiving requests for the duration of the registration. To avoid doing inappropriate or duplicate work, the <code>Lifecycle</code> listener code should include a check to only operate if its operating within the current <code>FacesContext</code>. I.e. Surround the listener function with a condition check that ensures the <code>FacesContext</code> passed in the event parameter to the method is the same as the <code>FacesContext</code> in the current thread (<code>FacesContext.getCurrentInstance</code>).</p><a id="a-name84"></a><h2><a name="8.4"></a>8.4 General Considerations</h2><p>Extensions should:</p>
<ol>
  <li>avoid interacting directly with container specific objects. Instead rely on  the <code>ExternalContext</code> abstraction.</li>
  <li>when interacting directly with container specific objects, provide support  for both the <code>Servlet</code> and <code>Portlet</code> containers.</li>
  <li>avoid completely overriding any method. Where its necessary to do so, the  extension must provide equivalent function as specified in this  specification.</li>
  <li>avoid caching the <code>FacesContext</code> and other dependent objects in your own  variables. In the portlet model the action and render phases span requests. A  likely bridge implementation creates/destroys the <code>FacesContext</code> for each  request. This means a different <code>FacesContext</code> (and dependent) instance  exists during the action phase then in the render phase. If you cache such  instances you will be referencing the wrong, destroyed instance.</li>
</ol><a id="a-name85"></a><h2><a name="8.5"></a>8.5 Cohabiting with the Bridge&rsquo;s ViewHandler</h2><p>Because of limitations in the Faces configuration environment there is no way to order extensions that are defined (exclusively) in the <code>faces-config.xml</code>. This applies to the Faces <code>ViewHandler</code>. This means when running in an environment where other subsystems also introduce a <code>ViewHandler</code>, one can&rsquo;t predict whether the bridge&rsquo;s <code>ViewHandler</code> will take precedence or not. The bridge is designed to cohabit with these other <code>ViewHandlers</code> regardless of the actual precedence order. However the same may not be true of these other <code>ViewHandlers</code>. To work correctly in a portlet environment with the bridge, other <code>ViewHandler</code> extensions are expected to:</p>
<ul>
  <li>Not run any (servlet) non-portlet container specific code when executing a portlet request.</li>
  <li>If the extension&rsquo;s <code>ViewHandler.createView()</code> returns its own <code>UIViewRoot</code> whose <code>Class.getName</code> isn&rsquo;t <code>javax.faces.component.UIViewRoot</code> then the extension should have its <code>UIViewRoot</code> implement the same semantics for portlet namespacing as described in section <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.6">6.6</a>. I.e. the implementation class of its <code>UIViewRoot</code> should be annotated to indicate it implements the portlet namespacing semantics and also provide such an implementation.</li>
  <li>If the extension&rsquo;s <code>ViewHandler.renderView()</code> handles its own form of rendering then the extension should ensure the same style of response interleaving as provided by the default <code>renderView</code> and the bridge.</li>
</ul><a id="a-name86"></a><h2><a name="8.6"></a>8.6 Cohabiting with the Bridge&rsquo;s StateManager</h2><p>Because of limitations in the Faces configuration environment there is no way to order extensions that are defined (exclusively) in the <code>faces-config.xml</code>. This applies to the Faces <code>StateManager</code>. This means when running in an environment where other subsystems also introduce a <code>StateManager</code> one can&rsquo;t predict whether the bridge&rsquo;s <code>StateManager</code> will take precedence or not. The bridge is designed to cohabit with these other <code>StateManagers</code> regardless of the actual precedence order. However the same may not be true of these other <code>StateManagers</code>. To work correctly in a portlet environment with the bridge, other <code>StateManager</code> extensions are expected to:</p>
<ul>
  <li>Not generate any output directly within the <code>writeState(FacesContext
context, Object state)</code>. I.e. the extension should rely/override other methods that are called when <code>writeState</code> is executed to generate any output. If this is not feasible, the extension developer should document the issue to inform portlet application developers that when using the extension in a bridge environment they need to move the <code>StateManager</code> configuration from the bridge jar&rsquo;s <code>faces-config.xml</code> and put it into the applications (<code>WEB-INF</code>) <code>faces-config.xml</code>. This ensures the bridge&rsquo;s <code>StateManager</code> runs before the extensions and hence isn&rsquo;t obscured by it.</li>
  <li>Delegate <code>writeState(FacesContext context, Object state)</code> to the next <code>StateManager</code> in the chain. Note: a common practice when implementing a <code>StateManager</code> (in earlier Faces versions) was to extend <code>javax.faces.application.StateManager</code> and to delegate calls to this super class. To work properly with the bridge such implementations need to change to delegate to the next <code>StateManager</code> in the chain. This is most easily done by reimplementing the <code>StateManager</code> as an extension of <code>javax.faces.application.StateManagerWrapper</code>.</li>
</ul><a id="a-name87"></a><h2><a name="8.7"></a>8.7 Excluding Attributes</h2><p>When executing an extension may store temporary state in the request scope. Because the bridge extends the life of this scope, extensions should explicitly exclude those attributes which do not need to be preserved. I.e. are recreated as needed in each (portlet) request. The preferred way to exclude such an attribute is to annotate the class of the attribute&rsquo;s value with <code>javax.portlet.faces.annotation.ExcludeFromManagedRequestScope</code>. If this is not feasible, attributes can be excluded by declaring them in the extension jar&rsquo;s <code>faces-config.xml</code> as described in <a href="Chapter-5-Bridge-Lifecycle-Requirements.html#5.1.2.1">5.1.2.1</a>. When using this technique care should be taken to only exclude attributes that are uniquely namespaced as other portlets in the same web application may rely on other extensions and/or attributes that might collide with a non-unique name and be mistakenly excluded. In such a situation when non-uniquely namespaced attributes are used, the extension developer should merely document for the portlet developer her need to configure such an exclusion in the application&rsquo;s portlet.xml for each portlet that utilizes the extension.</p><p><span style="font-weight: bold;"></span></span></div> <table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td>&nbsp; <a href="Chapter-7-BridgeRenderFilter.html">Previous</a></td> <td style="text-align: center;"><a href="TOC.html">Portlet 2.0 Bridge for JavaServer<small><sup>TM</sup></small>Faces 1.2 &ndash; November 14th, 2010</a></td> <td style="text-align: right;"><a href="Title-Page.html">Next</a> &nbsp;</td> </tr> </tbody> </table></p>
